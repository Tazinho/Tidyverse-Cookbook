[
["index.html", "Tidyverse Cookbook Prerequisites 0.1 This is work in progress 0.2 Motivation 0.3 Motivation for base R solutions 0.4 Structure of this book 0.5 Contribution 0.6 Conventions", " Tidyverse Cookbook Malte Grosser 2018-12-07 Prerequisites The basic idea of this book is to provide a documentation of the tidyverse written in a solution driven cookbook style. As an extra I would like to provide similar solutions based on base R functionality. 0.1 This is work in progress 0.2 Motivation Some reasons to write this book: Whenever I google for some specific tidyverse syntax, I have to search through different vignettes or blogposts spread across the internet. Other documents are focussed on teaching the tidyverse, but it is hard to find a quick solution to a specific problem. The tidyverse has grown a lot and most resources only touch the most common usecases. Whenever I know a solution in base R and want to achieve the same within a tidyverse workflow it takes some time to find the equivalent functionname. (Sometimes similar problems occur into the opposite direction.) I really like how this is solved in the stringr package vignette and I would like to have the opportunity to search for all tidyverse functions in this way (see also below). Bookdown gives great opportunities to share work. Bookdown also provides a fantastic structure for documentations. Writing a documentation is a good way to explore something, because you have to document everything just one time and can explore new stuff afterwards. This way I expect to find more cool functions like case_when() or common idioms, like regex handling in stringr functions, that will boost my code :) A nice longtime gain might be the possibility to learn R via flashcards copied from this book into systems like Anki to become more fluent in the future. It is a great way to get an overview of the tidyverse. 0.3 Motivation for base R solutions One strength of the tidyverse is that it hides a lot of quirks that base R provides and inherits to many packages that rely on it. This allows to stick to a specific workflow from the point you enter the tidyverse until you leave it. This is why I highly recommend to head your data analysis as fast as possible into the tidyverse workflow whenever possible. However, there might be situations where you need the functionality and concepts of the tidyverse, but you want to relay on base R. In these cases it is easy to get lost in quick workarounds that seem handy at first but hide some pitfalls that let you lose the way of a systematic data analysis workflow ending up in a unique non maintainable solution. Therefore I try to provide “good practice” solutions within base R that achieve the same goal as its tidyverse counterparts. This idea is somehow inspired by the stringr package vignette. While tidyverse solutions will usually be written in non-standard evaluation and usually provide an escape hatch, I’ll try to provide standard evaluation base R solutions. 0.4 Structure of this book The basics of the tidyverse are some shared idoms. Those give a structure, which makes it feasible that a lot of packages work so well together and enables to build up new functionality on top. The idea behind this was quickly understood by the community; grammars, that share these idioms, start to arise more often these days. It can be expected that the influence of the tidyverse will keep on growing and also the need for new connection and utility functions to integrate already established frameworks into the scope of the tidyverse will grow. This again could lead to new ideas, structures and relations to new fields of the tidyverse. Therefore this book might be work in progress for very long time and a final structure is not in sight. 0.5 Contribution This work is just a side project and any help is very much appreciated. Therefore you can find the edit button on top of each page. This lets you add changes to this book directly on github. My hope is that this book will be authored by the community and most of my future work is maintenance and keeping a structure that provides a good overview and lets you find the solution of your problem as fast as possible. To provide a contribution, please insert it directly into the regarding section. In case of doubts about the correct place, just add it to the last chapter. This book is not an introduction to the tidyverse. If you are new to it, I recommend R for Data Science and tidyverse.org. If you are curious about good base R practices I would first look in Advanced R. However, if you feel that you picked up a great solution for some specific task, feel free to come back to this book and add a pull request editing the appropriate section. If you do, please regard the following conventions. 0.6 Conventions 0.6.1 Tasks This book contains many reproducible examples. These should show intended usecases by package authors as well as other (maybe creative) uses that don’t have a simpler solution. All usecases are called “tasks” in this book and printed in bold. New tasks should be described by a sentence containing different verbs (some specific and some general), so that the tasks are easy to find. 0.6.2 Solutions All tasks should have a solution. Since this is a tidyverse cookbook, there should be at least one “tidy” solution. Whenever possible I would like an extra solution which is based on the base, methods (note that this package might not be loaded in batch mode), utils or stats packages. If no (or no straightforward) solution seems available, a solution from other packages should be given. In the latter case the libraries must be contained in the solution. If one solution has a disadvantage, this should also be described # by a comment at the top of the codepart. Some other easy rules should be applied: The solutions should always be an example, which is as easy as possible and as complex as necessary. The latter means that you should use easy datasets that don’t need much space to print (there might be a section with datasets to be used in the future). When you want to show something for one variable and the same concept also holds for more variables, then provide the example for a two variable case. When providing new solutions please use Hadley`s styleguide. General data and libraries should be included on top of each chapter, so that the code in the solutions is short and readable. In case of conflicts relating to two functions with the same name, but from different packages (or unique names, but from unpopular packages), then use the syntax packagename::functionname. When there seems to be two different base R or tidyverse approaches to a problem, just suffix these solutions with integers, eg. TDVS1, TDVS2, … . 0.6.3 Example task Task: Filter/subset a data.frame. TDVS: iris %&gt;% filter(Species == &quot;versicolor&quot; &amp; Sepal.Width &lt; 3) # or iris %&gt;% filter(Species == &quot;versicolor&quot;, Sepal.Width &lt; 3) BASE: iris[iris[, &quot;Species&quot;] == &quot;versicolor&quot; &amp; iris[, &quot;Sepal.Width&quot;] &lt; 3, drop = FALSE] Note the following considerations. Code: I think it’s best do include drop = FALSE every time, since it is so easy to forget. I used [ instead of $, because the first doesn’t use partial matching. The solution via brackets makes it also really easy to turn the code into a function like function(dat, var){dat[var, ]} iris[,&quot;Species&quot;] also makes clear that we want to subset a data frame by an atomic vetor, so I didn’t choose [[ or iris[&quot;Species&quot;]. I also didn’t choose subset(), since the base R solutions should use standard evaluation when possible. In the tidyverse solution I used the pipe as I think it’s general practice. Not included in this example, but for tasks about modification of atomics the solution might also be written within mutate(). I included a second tidyverse solution, to highlight, that you can not only filter by one logical expression but also by many, which are combined by &amp;. In this example it might not be super useful, but in many other cases with more named arguments it is really helpful to see, at which position the ... arguments are supplied. Formatting: Every task gets a number. Every solution should start on its own line, 4 spaces intended. To emphasize the solutions, use blue for TDVS and green for BASE. Above I wrote that different solutions should be highlighted via TDVS1, TDVS2, … . In these cases I think it is convenient to write everything in one solution, since they only show different possibilities of filter()’s syntax without any further big differences. The first version might be a little bit more compact, easier to program with and also minimal faster, that is why it is shown first. However, most of the above are just details and the structure might change anyway, so when in doubt just push your edits and I`ll try to take care on the remain. Contributors: "],
["idioms.html", "1 Idioms 1.1 The four basic principles to a tidy API 1.2 Resources", " 1 Idioms 1.1 The four basic principles to a tidy API These principles are likely to change. This version is from January 1st 2016. 1.1.1 Reuse existing data structures. try to use existing common base R structures instead of new customized ones if the latter is not possible create S3 classes based on a base R atomic or list use data frames or tibbles for rectangular data made up of observations and variables in rows and columns (which is basically tidy data) for “non-standard scoping”, prefer formulas over non-standard evaluation and use the lazyeval package. 1.1.2 Compose simple functions with the pipe. 1.1.3 Embrace functional programming. 1.1.4 Design for humans. 1.2 Resources The tidy tools manifesto "],
["non-standard-evaluation.html", "2 Non-standard evaluation 2.1 Formulas 2.2 Resources", " 2 Non-standard evaluation 2.1 Formulas 2.2 Resources non standard evalutaion vignette from dplyr "],
["read-and-write-data.html", "3 Read and write data 3.1 Flatfiles 3.2 Internet/Urls 3.3 Database connections 3.4 Cubes 3.5 Distributed Systems 3.6 Resources", " 3 Read and write data 3.1 Flatfiles 3.2 Internet/Urls 3.3 Database connections 3.4 Cubes 3.5 Distributed Systems 3.6 Resources "],
["data-frames-and-tibbles.html", "4 Data frames and tibbles 4.1 Basic operations and related stuff 4.2 Reshaping wide and long data 4.3 Typical mutate statements 4.4 Formatting 4.5 Joins 4.6 Tibbles 4.7 Resources", " 4 Data frames and tibbles 4.1 Basic operations and related stuff Task: Select a column and return it as vector (not data.frame). iris %&gt;% .$Species # ____________________________________________________________________________ iris[[&quot;Species&quot;]] Task: Select columns from (and return) data.frame. iris %&gt;% select(Sepal.Width, Species) # ____________________________________________________________________________ iris[, c(&quot;Sepal.Width&quot;, &quot;Species&quot;), drop = FALSE] Task: Filter/subset a data.frame. iris %&gt;% filter(Species == &quot;versicolor&quot; &amp; Sepal.Width &lt; 3) # ____________________________________________________________________________ iris[iris[, &quot;Species&quot;] == &quot;versicolor&quot; &amp; iris[, &quot;Sepal.Width&quot;] &lt; 3] Task: Mutate/transform/calculate new columns of a data.frame. iris %&gt;% mutate(a = Sepal.Length, b = 2 * a) # ____________________________________________________________________________ iris[[&quot;a&quot;]] &lt;- iris[[&quot;Sepal.Length&quot;]] iris[[&quot;b&quot;]] &lt;- 2 * iris[[&quot;a&quot;]] Task: Arrange/order a data.frame. dplyr::arrange(iris, dplyr::desc(Sepal.Length)) # ____________________________________________________________________________ iris[order(iris[&quot;Sepal.Length&quot;, ], decreasing = TRUE), ] Task: Rename colums iris %&gt;% dplyr::rename(a = Species, b = Sepal.Length) # or purrr::set_names() # or dplyr::select() # ____________________________________________________________________________ # Use names() or setNames() Task: Group and summarise a data.frame (#annonymous function). iris %&gt;% dplyr::group_by(Species) %&gt;% dplyr::summarise(n_rows = n(), dists = n_distinct(Sepal.Width, Sepal.Length), blub = (function(x) mean(x))(Sepal.Width), m = mean(Sepal.Length)) #&gt; # A tibble: 3 × 5 #&gt; Species n_rows dists blub m #&gt; &lt;fctr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 setosa 50 39 3.428 5.006 #&gt; 2 versicolor 50 44 2.770 5.936 #&gt; 3 virginica 50 44 2.974 6.588 # ____________________________________________________________________________ 4.2 Reshaping wide and long data Task: Gather/melt/unpivot/fold from wide into long format (two columns). data.frame(abc = sample(letters[1:3], 6, replace = TRUE), r1 = rnorm(6), r2 = rnorm(6), stringsAsFactors = FALSE) %&gt;% tidyr::gather(key = r, value = random, r1, r2) %&gt;% head(4) #&gt; abc r random #&gt; 1 c r1 -0.1607019 #&gt; 2 a r1 0.1618228 #&gt; 3 a r1 1.1763865 #&gt; 4 b r1 -0.9474683 # ____________________________________________________________________________ Task: Spread/cast/pivot/unfold from long into wide format (two columns). data.frame(abc = rep(letters[1:4], times = 2), r = rep(c(&quot;r1&quot;, &quot;r2&quot;), each = 4), random = rnorm(8), stringsAsFactors = FALSE) %&gt;% tidyr::spread(key = abc, value = random) %&gt;% head(1) #&gt; r a b c d #&gt; 1 r1 0.5033555 0.05401 -1.484874 -0.1451563 # ____________________________________________________________________________ 4.3 Typical mutate statements 4.3.1 Split and paste Task: Split/separate a column into one or more new columns. iris %&gt;% dplyr::transmute(Sepal.Length = as.character(Sepal.Length)) %&gt;% tidyr::separate(col = Sepal.Length, into = c(&quot;Sep1&quot;, &quot;Sep2&quot;), sep = &quot;\\\\.&quot;, remove = FALSE) %&gt;% head(1) #&gt; Warning: Too few values at 17 locations: 5, 8, 26, 27, 36, 41, 44, 50, 51, #&gt; 61, 63, 79, 84, 86, 94, 120, 139 #&gt; Sepal.Length Sep1 Sep2 #&gt; 1 5.1 5 1 Task: Combine/unite/paste one or more columns into one. iris[1,] %&gt;% tidyr::unite(new_col, Sepal.Width, Species, sep = &quot;&quot;, remove = FALSE) #&gt; Sepal.Length new_col Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5setosa 3.5 1.4 0.2 setosa iris[1,] %&gt;% dplyr::mutate(new_col = stringr::str_c(Sepal.Width, Species)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species new_col #&gt; 1 5.1 3.5 1.4 0.2 setosa 3.5setosa # ____________________________________________________________________________ 4.3.2 Conditionals Task: Mutate columns depending/conditionally on other colums. # use dplyr::case_when() or dplyr::if_else() # ____________________________________________________________________________ # use ifelse 4.3.3 IDs Task Add an id column. iris[1:2, ] %&gt;% dplyr::mutate(id = seq_len(n())) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species id #&gt; 1 5.1 3.5 1.4 0.2 setosa 1 #&gt; 2 4.9 3.0 1.4 0.2 setosa 2 # ____________________________________________________________________________ df &lt;- data.frame(a = 1:2) df[[&quot;id&quot;]] &lt;- seq_len(nrow(df)) Task Add a unique identifier regarding some columns (not in order). iris %&gt;% dplyr::mutate(id = as.integer(factor(stringr::str_c(Species, Sepal.Width)))) # ____________________________________________________________________________ iris[[&quot;id&quot;]] &lt;- as.integer(factor(paste0(iris[[&quot;Species&quot;]], iris[[&quot;Sepal.Width&quot;]]))) Task Add a unique identifier regarding all (or some) columns, in order off appearing unique rows. iris %&gt;% dplyr::mutate(id = iris %&gt;% purrr::pmap_chr(stringr::str_c, sep = &quot;\\t&quot;) %&gt;% factor %&gt;% forcats::fct_inorder(ordered = TRUE) %&gt;% as.integer) # ____________________________________________________________________________ 4.3.4 Other stuff Task: Use some helpers to select columns based on naming patterns iris[1,] %&gt;% dplyr::select(dplyr::starts_with(&quot;S&quot;, ignore.case = TRUE, vars = dplyr::current_vars())) #&gt; Sepal.Length Sepal.Width Species #&gt; 1 5.1 3.5 setosa iris[1,] %&gt;% dplyr::select(dplyr::ends_with(&quot;h&quot;)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 5.1 3.5 1.4 0.2 iris[1,] %&gt;% dplyr::select(dplyr::contains(&quot;.&quot;)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 5.1 3.5 1.4 0.2 iris[1,] %&gt;% dplyr::select(dplyr::matches(&quot;.&quot;)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa purrr::set_names(iris[1,], paste0(&quot;a&quot;, 1:5)) %&gt;% dplyr::select(dplyr::num_range(prefix = &quot;a&quot;, range = 2:4, width = 1)) #&gt; a2 a3 a4 #&gt; 1 3.5 1.4 0.2 iris[1, ] %&gt;% dplyr::select(dplyr::one_of(&quot;Sepal.Width&quot;, &quot;Species&quot;)) #&gt; Sepal.Width Species #&gt; 1 3.5 setosa # ____________________________________________________________________________ Task: Summarise grouped data by a statistic that returns more than one value. Task: Add summary data directly to the summarised data frame. 4.4 Formatting Task: Change column names to lower case. stringr::str_to_lower(names(iris)) #&gt; [1] &quot;sepal.length&quot; &quot;sepal.width&quot; &quot;petal.length&quot; &quot;petal.width&quot; #&gt; [5] &quot;species&quot; # ____________________________________________________________________________ tolower(names(iris)) #&gt; [1] &quot;sepal.length&quot; &quot;sepal.width&quot; &quot;petal.length&quot; &quot;petal.width&quot; #&gt; [5] &quot;species&quot; Task: Change column names to snake_case. library(magrittr) c(&quot;Var 1&quot;, &quot;Var-2&quot;, &quot;Var.3&quot;, &quot;Var4&quot;) %&gt;% stringr::str_replace_all(&quot;\\\\s|-|\\\\.&quot;, &quot;_&quot;) %&gt;% stringr::str_to_lower() #&gt; [1] &quot;var_1&quot; &quot;var_2&quot; &quot;var_3&quot; &quot;var4&quot; Task: Change column names from camelCase to snake_case. to_snake_case &lt;- function(camelcases){ # catch some input that should be handled like underscores too camelcases &lt;- stringr::str_replace_all(camelcases, &quot;\\\\s+|\\\\.+&quot;, &quot;_&quot;) # get to know, if a string starts with a small letter small_start &lt;- !is.na(stringr::str_extract(camelcases, &quot;^[a-z]&quot;)) # get all capital letter sequences from a string capitals &lt;- stringr::str_extract_all(camelcases, &quot;[A-Z]+&quot;) # Setting an underscore before capital and first letters starts &lt;- purrr::pmap(list(camelcases, small_start, capitals), function(x,y,z) if (length(z) == 0) {&quot;_&quot;} else { c(&quot;_&quot;, paste0(&quot;_&quot;, z)) } ) # split the strings by their capital letter sequences. rests &lt;- stringr::str_split(camelcases, &quot;[A-Z]+&quot;) # setting all peaces together: # - pasting first and capital letters with the rest of the string # - applying tolower, remove more than one &quot;_&quot; and starting &quot;_&quot; corrected &lt;- purrr::map2_chr(starts, rests, stringr::str_c, collapse = &quot;&quot;) %&gt;% purrr::map_chr(stringr::str_to_lower) %&gt;% purrr::map_chr(~ stringr::str_replace_all(.x, &quot;_+&quot;, &quot;_&quot;)) %&gt;% purrr::map_chr(~ stringr::str_replace_all(.x, &quot;^_+|_+$&quot;, &quot;&quot;)) corrected } camelCases &lt;- c(&quot;smallCamelCase&quot;, &quot;BigCamelCase&quot;, &quot;mixed_Case&quot;, &quot;snake_case&quot;, &quot;_camel_case__&quot;) to_snake_case(camelCases) #&gt; [1] &quot;small_camel_case&quot; &quot;big_camel_case&quot; &quot;mixed_case&quot; #&gt; [4] &quot;snake_case&quot; &quot;camel_case&quot; to_snake_case(names(iris)) #&gt; [1] &quot;sepal_length&quot; &quot;sepal_width&quot; &quot;petal_length&quot; &quot;petal_width&quot; #&gt; [5] &quot;species&quot; to_snake_case(c(&quot;.&quot;, &quot;_&quot;)) #&gt; [1] &quot;&quot; &quot;&quot; to_snake_case(NA) #&gt; [1] NA to_snake_case(NULL) #&gt; character(0) to_snake_case(character(0)) #&gt; character(0) to_snake_case(&quot; N A&quot;) #&gt; [1] &quot;n_a&quot; to_snake_case(&quot;LETTERS LETTERS&quot;) #&gt; [1] &quot;letters_letters&quot; to_snake_case(LETTERS) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; #&gt; [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; Task:: Change column names from snake_case to camelCase. Task: Mutate/Change/reorder columns depending on the row number (for example the last row). iris %&gt;% head(1) %&gt;% dplyr::select(Species, dplyr::everything()) #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 5.1 3.5 1.4 0.2 # ____________________________________________________________________________ setNames(iris[1, ], c(&quot;Species&quot;, setdiff(names(iris), &quot;Species&quot;))) #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 5.1 3.5 1.4 0.2 setosa Task Work on more than two tables (Reduce()) Task Convert rownames of a data frame into first column. 4.5 Joins Task: Join on two columns. 4.6 Tibbles 4.7 Resources https://www.r-bloggers.com/lesser-known-dplyr-tricks/ "],
["strings.html", "5 Strings 5.1 Basic string operations 5.2 Pattern matching 5.3 List output 5.4 Resources", " 5 Strings 5.1 Basic string operations How to use regular expressions? stringr::str_detect(&quot;1&quot;, &quot;\\\\d&quot;) #&gt; [1] TRUE # is the same as stringr::str_detect(&quot;1&quot;, stringr::regex(&quot;\\\\d&quot;)) #&gt; [1] TRUE # ____________________________________________________________________________ Paste/concatenate strings. stringr::str_c(&quot;a&quot;, &quot;b&quot;, NA, NaN, NULL, factor(&quot;lalala&quot;), character(0)) #&gt; [1] NA # ____________________________________________________________________________ paste(&quot;a&quot;, &quot;b&quot;, NA, NaN, NULL, factor(&quot;lalala&quot;), character(0), sep = &quot;&quot;) #&gt; [1] &quot;abNANaNlalala&quot; Treat NA’s as strings (&quot;NA&quot;). stringr::str_replace_na(c(NA, NaN, factor(&quot;lalala&quot;), character(0))) #&gt; [1] &quot;NA&quot; &quot;NaN&quot; &quot;1&quot; # note that the `c` function coerces the factor to its integer representation # ____________________________________________________________________________ base_replace_na &lt;- function(x) {ifelse(is.na(x), &quot;NA&quot;, x)} base_replace_na(c(NA, NaN, factor(&quot;lalala&quot;), character(0))) #&gt; [1] &quot;NA&quot; &quot;NaN&quot; &quot;1&quot; Count the number of letters in a string. stringr::str_length(c(&quot;four&quot;, NA, NaN, NULL, factor(&quot;lalala&quot;))) #&gt; [1] 4 NA 3 1 # ____________________________________________________________________________ nchar(c(&quot;four&quot;, NA, NaN, NULL, factor(&quot;lalala&quot;))) #&gt; [1] 4 NA 3 1 Return the last letter of a string, subset a string. stringr::str_sub(c(&quot;five&quot;, &quot;six&quot;), -1) #&gt; [1] &quot;e&quot; &quot;x&quot; # ____________________________________________________________________________ substr(c(&quot;five&quot;, &quot;six&quot;), start = nchar(c(&quot;five&quot;, &quot;six&quot;)), stop = nchar(c(&quot;five&quot;, &quot;six&quot;))) #&gt; [1] &quot;e&quot; &quot;x&quot; Repeat/replicate/duplicate a string several times. stringr::str_dup(&quot;_a_&quot;, 5) #&gt; [1] &quot;_a__a__a__a__a_&quot; # ____________________________________________________________________________ paste(rep(&quot;_a_&quot;, 5), collapse = &quot;&quot;) #&gt; [1] &quot;_a__a__a__a__a_&quot; Remove/trim spaces at the beginning (leading) and/or end (trailing) of a string. stringr::str_trim(c(&quot; 2left_1right &quot;, &quot; &quot;), side = c(&quot;left&quot;)) #&gt; [1] &quot;2left_1right &quot; &quot;&quot; # ____________________________________________________________________________ # ^\\\\s+|\\\\s+$ is the regex for one or more spaces in the beginning # or one or more spaces at the end gsub(&quot;^\\\\s+&quot;, &quot;&quot;, c(&quot; 2left_1right &quot;, &quot; &quot;)) #&gt; [1] &quot;2left_1right &quot; &quot;&quot; Fill/pad spaces (or other characters) before and/or after a string. stringr::str_pad(c(&quot;lalala&quot;, &quot;&quot;), width = 7) #&gt; [1] &quot; lalala&quot; &quot; &quot; # ____________________________________________________________________________ unname( vapply(c(&quot;lalala&quot;, &quot;&quot;), function(x) if(nchar(x) &lt; 7) { paste0(rep(&quot; &quot;, 7 - nchar(x)), x, collapse = &quot;&quot;) } else {x}, character(1) ) ) #&gt; [1] &quot; lalala&quot; &quot; &quot; Sort strings for example, by a different local alphabetic order. # The vowels come before the consonants in Hawaiian stringr::str_sort(letters[1:10], locale = &quot;haw&quot;) #&gt; [1] &quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;j&quot; # ____________________________________________________________________________ # one can use `sort()`, but one has to know the specific locale Return the order of stringelements within a specific alphabet # The vowels come before the consonants in Hawaiian stringr::str_order(letters[1:10], locale = &quot;haw&quot;) #&gt; [1] 1 5 9 2 3 4 6 7 8 10 # ____________________________________________________________________________ # one can use `sort()`, but one has to know the specific locale Change the encoding of a string # Example from encoding?stringi::stringi x &lt;- rawToChar(as.raw(177)) x #&gt; [1] &quot;±&quot; stringr::str_conv(x, &quot;ISO-8859-2&quot;) # Polish &quot;a with ogonek&quot;, (run this line in RStudio) #&gt; [1] &quot;a&quot; stringr::str_conv(x, &quot;ISO-8859-1&quot;) # Plus-minus #&gt; [1] &quot;±&quot; # ____________________________________________________________________________ Return the first two words of a string stringr::word(&quot;Hello, how are you?&quot;, 1, 2) #&gt; [1] &quot;Hello, how&quot; # ____________________________________________________________________________ Format a string (change width, indentaion, …). cat(stringr::str_wrap(&quot;Hello, how are you?&quot;, width = 10, indent = 0, exdent = 2)) #&gt; Hello, how #&gt; are you? # ____________________________________________________________________________ 5.2 Pattern matching How to disable case sensitivity in regex pattern? stringr::str_detect(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), stringr::regex(&quot;b|A|D&quot;, ignore_case = TRUE)) #&gt; [1] TRUE TRUE FALSE Does a string contain a specific sequence of characters? stringr::str_detect(c(&quot;my number is 110&quot;, &quot;call 911&quot;), &quot;\\\\d{3}&quot;) #&gt; [1] TRUE TRUE # ____________________________________________________________________________ grepl(&quot;\\\\d{3}&quot;, c(&quot;my number is 110&quot;, &quot;call 911&quot;)) #&gt; [1] TRUE TRUE Return every string that contains a specific sequence of characters? stringr::str_subset(c(&quot;my number is 110&quot;, &quot;call 911&quot;), &quot;\\\\d{3}&quot;) #&gt; [1] &quot;my number is 110&quot; &quot;call 911&quot; # ____________________________________________________________________________ grep(&quot;\\\\d{3}&quot;, c(&quot;my number is 110&quot;, &quot;call 911&quot;), value = TRUE) #&gt; [1] &quot;my number is 110&quot; &quot;call 911&quot; Return the (first) start and end index of substrings within a string? # use stringr::str_locate_all to get a matrix of all start and end indexes stringr::str_locate(c(&quot;my 112 number is 110&quot;, &quot;call 911&quot;), c(&quot;\\\\d{3}&quot;)) #&gt; start end #&gt; [1,] 4 6 #&gt; [2,] 6 8 # ____________________________________________________________________________ # Use gregexpr to construct something similar to str_locate_all matches &lt;- regexpr(&quot;\\\\d{3}&quot;, c(&quot;my 112 number is 110&quot;, &quot;call 911&quot;)) # formatting match_lengths &lt;- attr(matches, &quot;match.length&quot;) attributes(matches) &lt;- NULL match_indices &lt;- matrix(c(matches, matches + match_lengths - 1), ncol = 2) colnames(match_indices) &lt;- c(&quot;start&quot;, &quot;end&quot;) # output match_indices #&gt; start end #&gt; [1,] 4 6 #&gt; [2,] 6 8 Return the (first) matched substring within a string? # use stringr::str_extract_all to get a matrix of all matched substrings stringr::str_extract(c(&quot;my 112 number is 110&quot;, &quot;call 911&quot;), c(&quot;\\\\d{3}&quot;)) #&gt; [1] &quot;112&quot; &quot;911&quot; # ____________________________________________________________________________ # combine `substr()` with match_indices from above Return the matching strings and matched capture groups. # the example from the stringr vignette strings &lt;- c( &quot;apple&quot;, &quot;219 733 8965&quot;, &quot;329-293-8753&quot;, &quot;Work: 579-499-7527; Home: 543.355.3679&quot; ) phone &lt;- &quot;([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})&quot; stringr::str_match(strings, phone) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] NA NA NA NA #&gt; [2,] &quot;219 733 8965&quot; &quot;219&quot; &quot;733&quot; &quot;8965&quot; #&gt; [3,] &quot;329-293-8753&quot; &quot;329&quot; &quot;293&quot; &quot;8753&quot; #&gt; [4,] &quot;579-499-7527&quot; &quot;579&quot; &quot;499&quot; &quot;7527&quot; # Use stringr::str_match_all for list return # ____________________________________________________________________________ # `regmatches()` Replace/substitute the first matching subtstring within a string. stringr::str_replace(c(&quot;my 112 number is 110&quot;, &quot;call 911&quot;), c(&quot;\\\\d{1}(\\\\d{2})&quot;), &quot;\\\\1\\\\1&quot;) #&gt; [1] &quot;my 1212 number is 110&quot; &quot;call 1111&quot; # ____________________________________________________________________________ sub(c(&quot;\\\\d{1}(\\\\d{2})&quot;), &quot;\\\\1\\\\1&quot;, c(&quot;my 112 number is 110&quot;, &quot;call 911&quot;)) #&gt; [1] &quot;my 1212 number is 110&quot; &quot;call 1111&quot; Replace/substitute all matching subtstrings within a string. stringr::str_replace_all(c(&quot;my 112 number is 110&quot;, &quot;call 911&quot;), c(&quot;\\\\d{1}(\\\\d{2})&quot;), &quot;\\\\1\\\\1&quot;) #&gt; [1] &quot;my 1212 number is 1010&quot; &quot;call 1111&quot; # ____________________________________________________________________________ gsub(c(&quot;\\\\d{1}(\\\\d{2})&quot;), &quot;\\\\1\\\\1&quot;, c(&quot;my 112 number is 110&quot;, &quot;call 911&quot;)) #&gt; [1] &quot;my 1212 number is 1010&quot; &quot;call 1111&quot; Split strings by any pattern into different (optionally n) pieces. # returns a matrix and padds with empty strings, when n is greater than the # number of pieces stringr::str_split_fixed(c(&quot;lalala lala la&quot;, &quot;blabla lala la&quot;), c(&quot; &quot;, &quot;b&quot;), 5) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;lalala&quot; &quot;lala&quot; &quot;la&quot; &quot;&quot; &quot;&quot; #&gt; [2,] &quot;&quot; &quot;la&quot; &quot;la lala la&quot; &quot;&quot; &quot;&quot; # returns a list stringr::str_split(c(&quot;lalala lala la&quot;, &quot;blabla lala la&quot;), c(&quot; &quot;, &quot;b&quot;), 5) #&gt; [[1]] #&gt; [1] &quot;lalala&quot; &quot;lala&quot; &quot;la&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;&quot; &quot;la&quot; &quot;la lala la&quot; # ____________________________________________________________________________ # returns a list, but does not have an n argument (however, it shouldn&#39;t be # too hard to create one). strsplit(c(&quot;lalala lala la&quot;, &quot;blabla lala la&quot;), c(&quot; &quot;, &quot;b&quot;)) #&gt; [[1]] #&gt; [1] &quot;lalala&quot; &quot;lala&quot; &quot;la&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;&quot; &quot;la&quot; &quot;la lala la&quot; Set all characters to lower/upper case. stringr::str_to_lower(&quot;aBcDe&quot;) #&gt; [1] &quot;abcde&quot; stringr::str_to_upper(&quot;aBcDe&quot;) #&gt; [1] &quot;ABCDE&quot; # ____________________________________________________________________________ tolower(&quot;aBcDe&quot;) #&gt; [1] &quot;abcde&quot; toupper(&quot;aBcDe&quot;) #&gt; [1] &quot;ABCDE&quot; Truncate a string. stringr::str_trunc(&quot;123456789&quot;, width = 7, side = &quot;right&quot;, ellipsis = &quot;&quot;) #&gt; [1] &quot;1234567&quot; # ____________________________________________________________________________ 5.2.1 Regular expressions Where can I learn about regular expressions? ?stringr::modifiers for special regular expression functionality of the stringr package. reference sheet interactively test Build a regular expressin Try the str_view() function to see, which substring a regex matches ```r stringr::str_view(c(&quot;abc&quot;, &quot;a.c_blabla&quot;, &quot;bef&quot;), &quot;a\\\\.c&quot;) ``` How to test regular expressions? When writing regular expressions, I strongly recommend generating a list of positive (pattern should match) and negative (pattern shouldn’t match) test cases to ensure that you are matching the correct components. 5.2.2 Modifiers Count the number of words within a string. words &lt;- c(&quot;These are some words. Some more words.&quot;) stringr::str_count(words, stringr::boundary(&quot;word&quot;)) #&gt; [1] 7 # ____________________________________________________________________________ Count the number of lines within a string. stringr::str_count(words, stringr::boundary(&quot;line_break&quot;)) - stringr::str_count(words, stringr::boundary(&quot;word&quot;)) #&gt; [1] 1 # ____________________________________________________________________________ Count the number of sentences within a string. stringr::str_count(words, stringr::boundary(&quot;sentence&quot;)) #&gt; [1] 2 # ____________________________________________________________________________ Split a string by characters. stringr::str_split(words, stringr::boundary(&quot;character&quot;)) #&gt; [[1]] #&gt; [1] &quot;T&quot; &quot;h&quot; &quot;e&quot; &quot;s&quot; &quot;e&quot; &quot; &quot; &quot;a&quot; &quot;r&quot; &quot;e&quot; &quot; &quot; &quot;s&quot; &quot;o&quot; &quot;m&quot; &quot;e&quot; #&gt; [15] &quot; &quot; &quot;w&quot; &quot;o&quot; &quot;r&quot; &quot;d&quot; &quot;s&quot; &quot;.&quot; &quot; &quot; &quot;\\n&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; #&gt; [29] &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;S&quot; &quot;o&quot; &quot;m&quot; &quot;e&quot; &quot; &quot; &quot;m&quot; &quot;o&quot; &quot;r&quot; #&gt; [43] &quot;e&quot; &quot; &quot; &quot;w&quot; &quot;o&quot; &quot;r&quot; &quot;d&quot; &quot;s&quot; &quot;.&quot; # ____________________________________________________________________________ strsplit(words, &quot;&quot;) #&gt; [[1]] #&gt; [1] &quot;T&quot; &quot;h&quot; &quot;e&quot; &quot;s&quot; &quot;e&quot; &quot; &quot; &quot;a&quot; &quot;r&quot; &quot;e&quot; &quot; &quot; &quot;s&quot; &quot;o&quot; &quot;m&quot; &quot;e&quot; #&gt; [15] &quot; &quot; &quot;w&quot; &quot;o&quot; &quot;r&quot; &quot;d&quot; &quot;s&quot; &quot;.&quot; &quot; &quot; &quot;\\n&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; #&gt; [29] &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;S&quot; &quot;o&quot; &quot;m&quot; &quot;e&quot; &quot; &quot; &quot;m&quot; &quot;o&quot; &quot;r&quot; #&gt; [43] &quot;e&quot; &quot; &quot; &quot;w&quot; &quot;o&quot; &quot;r&quot; &quot;d&quot; &quot;s&quot; &quot;.&quot; 5.3 List output How to work with string functions, that return lists? 5.4 Resources stringr vignette [Regular Expressions in R - Cheatsheet]https://www.rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf "],
["factors.html", "6 Factors 6.1 Resources", " 6 Factors Task: Create a factor. # ____________________________________________________________________________ factor(letters) #&gt; [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z Task: Check if an atomic vector is a factor. # ____________________________________________________________________________ is.factor(factor(letters)) #&gt; [1] TRUE Task: Create an ordered factor. # ____________________________________________________________________________ factor(letters, ordered = TRUE) #&gt; [1] a b c d e f g h i j k l m n o p q r s t u v w x y z #&gt; 26 Levels: a &lt; b &lt; c &lt; d &lt; e &lt; f &lt; g &lt; h &lt; i &lt; j &lt; k &lt; l &lt; m &lt; n &lt; ... &lt; z Task: Check if a factor is ordered. # ____________________________________________________________________________ is.ordered(factor(letters)) #&gt; [1] FALSE Task: Add a factor level. # ____________________________________________________________________________ a &lt;- factor(letters[1:5]) levels(a) &lt;- c(levels(a), &quot;new_level&quot;) a #&gt; [1] a b c d e #&gt; Levels: a b c d e new_level Task: Add a value (that is not a level of the factor). # ____________________________________________________________________________ a &lt;- factor(letters[1:5]) a &lt;- factor(c(as.character(a), &quot;new_level&quot;)) a #&gt; [1] a b c d e new_level #&gt; Levels: a b c d e new_level Task: Combine two factors. # ____________________________________________________________________________ a &lt;- factor(letters[1:5]) b &lt;- factor(letters[3:7]) factor(c(as.character(a), as.character(b))) #&gt; [1] a b c d e c d e f g #&gt; Levels: a b c d e f g Task: Sort the levels of a factor by another variable. Task: Reorder the levels of a factor by another variable. Task: Reverse the order of factor levels. Task: Change specific levels of a factor by name, while preserving the order. a &lt;- factor(letters[1:5]) forcats::fct_recode(a, g= &quot;a&quot;, h = &quot;b&quot;) #&gt; [1] g h c d e #&gt; Levels: g h c d e # Note that the folowing will not work, since f is also the argument name of the # data: forcats::fct_recode(a, f= &quot;a&quot;, g = &quot;b&quot;) Task: Delete a factor level. a &lt;- factor(letters[1:5]) forcats::fct_recode(a, NULL= &quot;a&quot;, h = &quot;b&quot;) #&gt; [1] &lt;NA&gt; h c d e #&gt; Levels: h c d e Task: Move specific factor levels in front of all others. Task: Count factors/strings. a &lt;- factor(rep(letters[1:5], 5:1)) forcats::fct_count(a) #&gt; # A tibble: 5 × 2 #&gt; f n #&gt; &lt;fctr&gt; &lt;int&gt; #&gt; 1 a 5 #&gt; 2 b 4 #&gt; 3 c 3 #&gt; 4 d 2 #&gt; 5 e 1 Task: Join/bind/combine/compose/unite rare/common factor levels into one. a &lt;- rep(letters[1:5], 5:1) forcats::fct_lump(a, n = 2) #&gt; [1] a a a a a b b b b Other Other #&gt; [12] Other Other Other Other #&gt; Levels: a b Other forcats::fct_lump(a, n = -2) #&gt; [1] Other Other Other Other Other Other Other Other Other Other Other #&gt; [12] Other d d e #&gt; Levels: d e Other 6.1 Resources forcats 0.1 on RStudio blog "],
["dates-and-times.html", "7 Dates and times 7.1 Dates 7.2 Dates and Times 7.3 Intervals 7.4 Resources", " 7 Dates and times 7.1 Dates Task: Convert a string into a date. lubridate::ymd(&quot;2016-01-01&quot;) # also &quot;2016/01/01&quot;, &quot;20160101&quot; and &quot;2016:01:01&quot; will work #&gt; [1] &quot;2016-01-01&quot; # ____________________________________________________________________________ as.Date.character(&quot;2016-01-01&quot;) # also &quot;2016/01/01&quot; will work #&gt; [1] &quot;2016-01-01&quot; Task: Add days (as an integer) to a date. lubridate::ymd(&quot;2016-01-01&quot;) + 5 #&gt; [1] &quot;2016-01-06&quot; # ____________________________________________________________________________ as.Date.character(&quot;2016-01-01&quot;) + 5 #&gt; [1] &quot;2016-01-06&quot; Task: Generate a (dense) sequence of days/weeks/months/years. lubridate::ymd(&quot;2016-01-01&quot;) + lubridate::days(0:3) #&gt; [1] &quot;2016-01-01&quot; &quot;2016-01-02&quot; &quot;2016-01-03&quot; &quot;2016-01-04&quot; lubridate::ymd(&quot;2016-01-01&quot;) + lubridate::weeks(0:3) #&gt; [1] &quot;2016-01-01&quot; &quot;2016-01-08&quot; &quot;2016-01-15&quot; &quot;2016-01-22&quot; lubridate::ymd(&quot;2016-01-01&quot;) + lubridate::month(0:3) #&gt; [1] &quot;2016-01-01&quot; &quot;2016-01-02&quot; &quot;2016-01-03&quot; &quot;2016-01-04&quot; lubridate::ymd(&quot;2016-01-01&quot;) + lubridate::years(0:3) #&gt; [1] &quot;2016-01-01&quot; &quot;2017-01-01&quot; &quot;2018-01-01&quot; &quot;2019-01-01&quot; lubridate::ymd(&quot;2012-01-01&quot;) + lubridate::dyears(1) # adds 365 days also for leap years #&gt; [1] &quot;2012-12-31&quot; TASK: Get the exact difference between two dates in days or other units: as.double(difftime(lubridate::ymd_hms(&quot;2016-01-01 08:04:20&quot;), lubridate::ymd_hms(&quot;2016-04-01 12:03:00&quot;), units = &quot;days&quot;)) #&gt; [1] -91.16574 # ____________________________________________________________________________ Task: Get the day of a week as an integer or as its name. lubridate::wday(&quot;2016-01-01&quot;) #&gt; [1] 6 lubridate::wday(&quot;2016-01-01&quot;, label = TRUE) #&gt; [1] Fri #&gt; Levels: Sun &lt; Mon &lt; Tues &lt; Wed &lt; Thurs &lt; Fri &lt; Sat # ____________________________________________________________________________ Task: Get the day/month/year from a date. lubridate::day(&quot;2016-01-01&quot;) #&gt; [1] 1 lubridate::week(&quot;2016-01-01&quot;) #&gt; [1] 1 lubridate::month(&quot;2016-01-01&quot;) #&gt; [1] 1 lubridate::month(&quot;2016-01-01&quot;, label = TRUE) #&gt; [1] Jan #&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec lubridate::year(&quot;2016-01-01&quot;) #&gt; [1] 2016 # ____________________________________________________________________________ Task: What happens if dates are not valid? lubridate::ymd(&quot;20160142&quot;) #&gt; Warning: All formats failed to parse. No formats found. #&gt; [1] NA jan31 &lt;- ymd(&quot;2013-01-31&quot;) jan31 + months(0:11) #&gt; [1] &quot;2013-01-31&quot; NA &quot;2013-03-31&quot; NA &quot;2013-05-31&quot; #&gt; [6] NA &quot;2013-07-31&quot; &quot;2013-08-31&quot; NA &quot;2013-10-31&quot; #&gt; [11] NA &quot;2013-12-31&quot; floor_date(jan31, &quot;month&quot;) + months(0:11) + days(31) #&gt; [1] &quot;2013-02-01&quot; &quot;2013-03-04&quot; &quot;2013-04-01&quot; &quot;2013-05-02&quot; &quot;2013-06-01&quot; #&gt; [6] &quot;2013-07-02&quot; &quot;2013-08-01&quot; &quot;2013-09-01&quot; &quot;2013-10-02&quot; &quot;2013-11-01&quot; #&gt; [11] &quot;2013-12-02&quot; &quot;2014-01-01&quot; lubridate::`%m+%`(jan31, months(0:11)) #&gt; [1] &quot;2013-01-31&quot; &quot;2013-02-28&quot; &quot;2013-03-31&quot; &quot;2013-04-30&quot; &quot;2013-05-31&quot; #&gt; [6] &quot;2013-06-30&quot; &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2013-09-30&quot; &quot;2013-10-31&quot; #&gt; [11] &quot;2013-11-30&quot; &quot;2013-12-31&quot; Task: Get the last day of a month last_day &lt;- function(date) { lubridate::ceiling_date(date, &quot;month&quot;) - lubridate::days(1) } last_day(lubridate::ymd(&quot;2016-01-01&quot;)) #&gt; [1] &quot;2016-01-31&quot; Task: Check if a year is a leap/non regular year: lubridate::leap_year(2011) #&gt; [1] FALSE # ____________________________________________________________________________ 7.2 Dates and Times Task: Subtract dates/date-times. Task: Convert to date-time (and set a specific timezone). lubridate::ymd_hms(&quot;2011-06-04 12:00:00&quot;, tz = &quot;Pacific/Auckland&quot;) #&gt; [1] &quot;2011-06-04 12:00:00 NZST&quot; Task: Get the second/minute/hour from a date. lubridate::second(lubridate::ymd_hms(&quot;2011-06-04 12:00:00&quot;, tz = &quot;Pacific/Auckland&quot;)) #&gt; [1] 0 lubridate::minute(lubridate::ymd_hms(&quot;2011-06-04 12:00:00&quot;, tz = &quot;Pacific/Auckland&quot;)) #&gt; [1] 0 lubridate::hour(lubridate::ymd_hms(&quot;2011-06-04 12:00:00&quot;, tz = &quot;Pacific/Auckland&quot;)) #&gt; [1] 12 # ____________________________________________________________________________ Task: Change the time depending on a timezone. meeting &lt;- lubridate::ymd_hms(&quot;2011-07-01 09:00:00&quot;, tz = &quot;Pacific/Auckland&quot;) lubridate::with_tz(meeting, &quot;America/Chicago&quot;) #&gt; [1] &quot;2011-06-30 16:00:00 CDT&quot; # ____________________________________________________________________________ 7.3 Intervals Task: Create an interval. int1 &lt;- lubridate::interval(lubridate::ymd_hms(&quot;2011-06-04 12:00:00&quot;), lubridate::ymd_hms(&quot;2011-08-10 14:00:00&quot;)) # or int2 &lt;- lubridate::`%--%`(lubridate::ymd(&quot;2011-07-20&quot;), lubridate::ymd(&quot;2011-08-31&quot;)) # ____________________________________________________________________________ Task: Check if two intervals overlap. lubridate::int_overlaps(int1, int2) #&gt; [1] TRUE # ____________________________________________________________________________ Task: What is the intersection of two intervals? lubridate::intersect(int1, int2) #&gt; [1] 2011-07-20 UTC--2011-08-10 14:00:00 UTC # ____________________________________________________________________________ Task: What is the setdiff of two intervals (one interval without the other)? setdiff(int1, int2) #&gt; [1] 2011-06-04 12:00:00 UTC--2011-07-20 UTC # ____________________________________________________________________________ Task: What is the begin/end of the interval? lubridate::int_start(int1) #&gt; [1] &quot;2011-06-04 12:00:00 UTC&quot; lubridate::int_end(int1) #&gt; [1] &quot;2011-08-10 14:00:00 UTC&quot; # ____________________________________________________________________________ Task: How to reverse the start and end of an interval? lubridate::int_flip(int1) #&gt; [1] 2011-08-10 14:00:00 UTC--2011-06-04 12:00:00 UTC # ____________________________________________________________________________ Task: Add/substract an amount of time to an interval. lubridate::int_shift(int1, by = seconds(102)) #&gt; [1] 2011-06-04 12:01:42 UTC--2011-08-10 14:01:42 UTC # ____________________________________________________________________________ Task: Check if two intervals are starting or ending at the same time. lubridate::int_aligns(int1, int2) #&gt; [1] FALSE # ____________________________________________________________________________ Task: Unite two intevals into one. lubridate::union(int1, int2) #&gt; [1] 2011-06-04 12:00:00 UTC--2011-08-31 UTC # ____________________________________________________________________________ Task Check if a date-time lies within an interval. lubridate::`%within%`(lubridate::ymd_hms(&quot;2011-06-06 12:12:12&quot;), int1) #&gt; [1] TRUE # ____________________________________________________________________________ Task: What are general time intervals available and what are their differences? # Intervals are specific time spans (because they are tied to specific dates) # Durations will always supply mathematically precise results, for example # duration year will always equal 365 days. # Periods fluctuate the same way the timeline does to give intuitive results. # This makes them useful for modeling clock times. lubridate::minutes(2) ## period #&gt; [1] &quot;2M 0S&quot; lubridate::dminutes(2) ## duration #&gt; [1] &quot;120s (~2 minutes)&quot; Task: Perform calculations with intervals: int1 / lubridate::ddays(2) #&gt; [1] 33.54167 int1 / lubridate::dminutes(1) #&gt; [1] 96600 int1 %/% months(1) #&gt; Note: method with signature &#39;Timespan#Timespan&#39; chosen for function &#39;%/%&#39;, #&gt; target signature &#39;Interval#Period&#39;. #&gt; &quot;Interval#ANY&quot;, &quot;ANY#Period&quot; would also be valid #&gt; [1] 2 lubridate::as.period(int1) #&gt; [1] &quot;2m 6d 2H 0M 0S&quot; lubridate::as.period(int1 %% months(1)) #&gt; [1] &quot;6d 2H 0M 0S&quot; # ____________________________________________________________________________ 7.4 Resources original lubridate paper lubridate google group development page on github lubridate vignette "],
["lists.html", "8 Lists", " 8 Lists TASK: Convert data.frame into a list, rowwise TASK: Convert data.frame into a list, columnwise "],
["list-columns-within-data-frames.html", "9 List columns within data frames", " 9 List columns within data frames "],
["tidy-data-structures.html", "10 Tidy data structures", " 10 Tidy data structures "],
["models.html", "11 Models 11.1 Resources", " 11 Models Task: Extract coefficients from a model. library(magrittr) lm(Sepal.Width ~ Species, data = iris) %&gt;% broom::tidy(.) #&gt; term estimate std.error statistic p.value #&gt; 1 (Intercept) 3.428 0.04803910 71.358540 5.707614e-116 #&gt; 2 Speciesversicolor -0.658 0.06793755 -9.685366 1.832489e-17 #&gt; 3 Speciesvirginica -0.454 0.06793755 -6.682608 4.538957e-10 # ____________________________________________________________________________ Task: Extract residuals from a model. lm(Sepal.Width ~ Species, data = iris) %&gt;% broom::augment(.) %&gt;% head() #&gt; Sepal.Width Species .fitted .se.fit .resid .hat .sigma .cooksd #&gt; 1 3.5 setosa 3.428 0.0480391 0.072 0.02 0.3407959 0.0003118616 #&gt; 2 3.0 setosa 3.428 0.0480391 -0.428 0.02 0.3389658 0.0110200713 #&gt; 3 3.2 setosa 3.428 0.0480391 -0.228 0.02 0.3403157 0.0031272785 #&gt; 4 3.1 setosa 3.428 0.0480391 -0.328 0.02 0.3397443 0.0064720901 #&gt; 5 3.6 setosa 3.428 0.0480391 0.172 0.02 0.3405456 0.0017797285 #&gt; 6 3.9 setosa 3.428 0.0480391 0.472 0.02 0.3385573 0.0134023471 #&gt; .std.resid #&gt; 1 0.2141113 #&gt; 2 -1.2727728 #&gt; 3 -0.6780191 #&gt; 4 -0.9753959 #&gt; 5 0.5114881 #&gt; 6 1.4036185 # ____________________________________________________________________________ Task: Extract measures of fit from a model. lm(Sepal.Width ~ Species, data = iris) %&gt;% broom::glance() #&gt; r.squared adj.r.squared sigma statistic p.value df logLik #&gt; 1 0.4007828 0.3926302 0.3396877 49.16004 4.492017e-17 3 -49.3663 #&gt; AIC BIC deviance df.residual #&gt; 1 106.7326 118.7751 16.962 147 # ____________________________________________________________________________ 11.1 Resources "],
["statistics.html", "12 Statistics 12.1 Resources", " 12 Statistics 12.1 Resources "],
["text-mining.html", "13 Text mining 13.1 Resources", " 13 Text mining 13.1 Resources Tidy Text Mining with R "],
["time-series.html", "14 Time series 14.1 Resources", " 14 Time series 14.1 Resources "],
["web-scraping.html", "15 Web scraping 15.1 Resources", " 15 Web scraping 15.1 Resources "],
["utilities.html", "16 Utilities 16.1 Control structures 16.2 Pipes 16.3 Resources", " 16 Utilities 16.1 Control structures Task: Nested ifelse Task: ifelse 16.2 Pipes 16.3 Resources "],
["testchapter.html", "17 Testchapter 17.1 New contributions 17.2 Proposal for Description", " 17 Testchapter If you would like to contribute, please include your new tasks and/or solutions via editing this file. 17.1 New contributions Task: &lt;Description of the task&gt; TDVS: &lt;some optional description&gt; # some code BASE: &lt;some optional description&gt; # some code 17.2 Proposal for Description Vorschlag für die github-repository-description: “A tidyverse-oriented cookbook for common tasks in R” Tags: r, tidyverse, cookbook "],
["rstudio-project-management.html", "18 RStudio project management 18.1 Project types 18.2 Project options 18.3 Version control 18.4 Packrat and package dependencies 18.5 Addins 18.6 Miscellaneous", " 18 RStudio project management 18.1 Project types Empty project, package or shiny web applications 18.2 Project options 18.3 Version control copy the link from a remote repository, when creating a new package git add . git add -m “some commit message” push to remote 18.4 Packrat and package dependencies Resources: Packrat Webinar by RStudio Packrat Homepage Most important commands: packrat::init(), initializes an isolated package library for the current project. packrat::snapshot() saves all changes within the packrat project library since the last snapshot. packrat::restore() deletes all changes within the packrat project library since the last snapshot. packrat::bundle() creates a tarball of the project, the packages and its dependencies. packrat::unbundle(bundle = &quot;path//to//the//bundle&quot;, where = &quot;.&quot;) unbundles (restores) a project within a subdirectory of another (conveniently empty) project. packrat::off() lets you temporarily step out of “packrat mode”, which means, that you will now use your global user library instead of the packrat project library. packrat::on() lets you go back into “packrat mode”. Collaboration: Initialise a packrat project on github, let everyone clone it and let them then call packrat::restore(). Updated R Version: When you unbundle a project, which was created under an older (or newer) R version, then installed, packrat will warn you and install the older (or newer) R version when calling packrat::snapshot(). This is one among other reasons, why it is easier to work with packrat, while having access to the internet. 18.5 Addins Task: Structure/separate code into blocks by different lines of lentgh 80 (by default). General: Use devtools::install_github(&quot;lorenzwalthert/strcode&quot;) within your project (to install the strcode package from here). That will enable the following: strcode::insert_l1_break() # or strg + c + 1 (shortcut) # ____________________________________________________________________________ strcode::insert_l2_break() # or strg + c + 1 ## ............................................................................ strcode::insert_l3_break() # or strg + c + 1 ### .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18.6 Miscellaneous Task: Build a website with rmarkdown. General: Create a github repository with the name &lt;yourusername&gt;.github.io Create an empty RStudio project synchronized with the github repository Create a textfile _site.yml and two rmarkdown files index.Rmd and about.Rmd (also include an empty textfile called .nojekyll [this tells GitHub Pages to not process your site with the Jekyll engine]) _site.yml name: &quot;my-website&quot; navbar: title: &quot;My Website&quot; left: - text: &quot;Home&quot; href: index.html - text: &quot;About&quot; href: about.html output: html_document: theme: cosmo highlight: textmate output_dir: &quot;.&quot; output_dir “.” is set to achive that the output htmls are created on the top level of the repository and not within the site folder. index.Rmd --- title: &quot;My Website&quot; --- Hello, Website! about.Rmd --- title: &quot;About This Website&quot; --- More about this website. Save the files above and call rmarkdown::render_site() or close and reopen RStudio and lock for a build pane within RStudio, which lets you build the side. You should see the output now in the viewer pane Open the shell and call git add . Then call commit -m “first build” Then call git push You should see the output within the browser under &lt;yourusername&gt;.github.io Resources: rmarkdown website instructions almost the same tutorial as above video detailed tutorial "],
["labelled-data.html", "19 Labelled data 19.1 Basic operations", " 19 Labelled data 19.1 Basic operations How to load labelled data? #TDVS SOLUTION # ____________________________________________________________________________ #BASE R Solution "],
["spatial-data.html", "20 Spatial data 20.1 IO 20.2 Objects 20.3 Arithmetics 20.4 Plots 20.5 Resources", " 20 Spatial data 20.1 IO How to load/read and save/write spatial data? library(sf) ## Linking to GEOS 3.5.1, GDAL 2.1.3, proj.4 4.9.2, lwgeom 2.3.2 r15302 nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;), quiet = TRUE) # st_write(nc, &quot;nc.shp&quot;) # see st_read_db() and st_write_db() for spatial databases # look carefully through all of the arguments (especially layers, # stringsAsFactors, geometry_column, type, quiet) # in case of specific problems see: # https://edzer.github.io/sfr/articles/sf2.html # ____________________________________________________________________________ 20.2 Objects What are the classes of sf-objects? # the data.frame class(nc) #&gt; [1] &quot;sf&quot; &quot;data.frame&quot; # the geometry list-column class(st_geometry(nc)) #&gt; [1] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot; # the individual feature geometries lapply(st_geometry(dplyr::slice(nc, 1:2)), class) #&gt; [[1]] #&gt; [1] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; Which methods are avaliable for sf-objects? methods(class = &quot;sf&quot;) #&gt; [1] $&lt;- [ [[&lt;- #&gt; [4] aggregate anti_join arrange_ #&gt; [7] cbind distinct_ filter_ #&gt; [10] full_join group_by_ inner_join #&gt; [13] left_join merge mutate_ #&gt; [16] plot print rbind #&gt; [19] rename_ right_join sample_frac #&gt; [22] sample_n select_ semi_join #&gt; [25] slice_ st_agr st_agr&lt;- #&gt; [28] st_as_sf st_bbox st_boundary #&gt; [31] st_buffer st_cast st_centroid #&gt; [34] st_convex_hull st_coordinates st_crs #&gt; [37] st_crs&lt;- st_difference st_geometry #&gt; [40] st_geometry&lt;- st_intersection st_is #&gt; [43] st_line_merge st_make_valid st_polygonize #&gt; [46] st_precision st_segmentize st_set_precision #&gt; [49] st_simplify st_sym_difference st_transform #&gt; [52] st_triangulate st_union st_voronoi #&gt; [55] st_zm summarise_ transmute_ #&gt; see &#39;?methods&#39; for accessing help and source code methods(class = &#39;sfc&#39;) #&gt; [1] [ c format #&gt; [4] print st_as_binary st_as_text #&gt; [7] st_bbox st_boundary st_buffer #&gt; [10] st_cast st_centroid st_convex_hull #&gt; [13] st_coordinates st_crs st_crs&lt;- #&gt; [16] st_difference st_geometry st_intersection #&gt; [19] st_is st_line_merge st_make_valid #&gt; [22] st_polygonize st_precision st_segmentize #&gt; [25] st_set_precision st_simplify st_sym_difference #&gt; [28] st_transform st_triangulate st_union #&gt; [31] st_voronoi st_zm str #&gt; [34] summary type_sum #&gt; see &#39;?methods&#39; for accessing help and source code methods(class = &#39;sfg&#39;) #&gt; [1] as.matrix c format #&gt; [4] head plot print #&gt; [7] st_as_binary st_as_text st_boundary #&gt; [10] st_buffer st_centroid st_convex_hull #&gt; [13] st_coordinates st_difference st_geometry #&gt; [16] st_intersection st_is st_line_merge #&gt; [19] st_make_valid st_polygonize st_segmentize #&gt; [22] st_simplify st_sym_difference st_transform #&gt; [25] st_triangulate st_union st_voronoi #&gt; [28] st_zm #&gt; see &#39;?methods&#39; for accessing help and source code What sf-geometry types are available, how do you initialize them and what types are the internally? # internal types: # - point (atomic) # - linestring (matrix) # - everything else (list) ## common geometries # point st_point(c(1,2)) # linestring st_linestring(rbind(c(0.2,3), c(0.2,4), c(1,4.8), c(2,4.8))) # polygon st_polygon(list( rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0)), rbind(c(1,1), c(1,2), c(2,2), c(1,1)))) # multipoint st_multipoint(rbind(c(3.2,4), c(3,4.6), c(3.8,4.4), c(3.5,3.8), c(3.4,3.6))) # multilinestring st_multilinestring(list(rbind(c(0.2,3), c(0.2,4), c(1,4.8), c(2,4.8)), rbind(c(0,4.4), c(0.6,5)))) # multipolygon st_multipolygon(list( list(rbind(c(0,0), c(1,0), c(3,2), c(2,4), c(1,4), c(0,0)), rbind(c(1,1), c(1,2), c(2,2), c(1,1))), list(rbind(c(3,0), c(4,0), c(4,1), c(3,1), c(3,0)), rbind(c(3.3,0.3), c(3.8,0.3), c(3.8,0.8), c(3.3,0.8), c(3.3,0.3))[5:1,]), list(rbind(c(3,3), c(4,2), c(4,3), c(3,3))))) # geometrycollection st_sfc(st_geometrycollection(list(st_point(1:2))), st_geometrycollection(list(st_linestring(matrix(1:4,2))))) # geometry st_sfc(st_point(1:2), st_linestring(matrix(1:4,2))) # like the latter, but as a &quot;superclass&quot; ## rare geometries # circularstring # compoundcurve # curvepolygon # multicurve # multisurface # curve # surface # polyhedral surface # tin # triangle What are the dimensions of those objects? x = st_sfc( st_point(0:1), st_linestring(rbind(c(0,0),c(1,1))), st_polygon(list(rbind(c(0,0),c(1,0),c(0,1),c(0,0)))), st_multipoint(), st_linestring(), st_geometrycollection()) st_dimension(x, NA_if_empty = FALSE) #&gt; [1] 0 1 2 0 1 0 How to initialize these objects from well known text? st_as_sfc(&quot;POINT(0 1)&quot;) #&gt; Geometry set for 1 feature #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: 1 xmax: 0 ymax: 1 #&gt; epsg (SRID): NA #&gt; proj4string: NA #&gt; POINT(0 1) How to initialize an sf-object and bring it into coordinate reference systems (crs)? # attributes of sfc obejects to store a crs: epsg, proj4string # theses must be the same for all elements of an sfc-object, but can also be NA. # -proj4string is a generic, string-based description of crs # - epsg integer values refer to particular well known crs, that might also # improve over time st_sf(points = st_sfc(st_point(c(0, 0)), st_point(c(0, 1)), crs = 4326)) #&gt; Simple feature collection with 2 features and 0 fields #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: 0 ymin: 0 xmax: 0 ymax: 1 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs #&gt; points #&gt; 1 POINT(0 0) #&gt; 2 POINT(0 1) # also use: # use st_crs() and st_transform() How to coerce data.frames to sf? # use st_as_sf How to create and identify empty geometries? st_geometrycollection() #&gt; GEOMETRYCOLLECTION() length(st_geometrycollection()) #&gt; [1] 0 How to identify unconnected parts of geometries? which(sapply(st_geometry(nc), length) &gt; 1) #&gt; [1] 4 56 57 87 91 95 How to switch between well-known text and well-known binary encoding? x &lt;- st_linestring(matrix(10:1,5)) st_as_text(x) #&gt; [1] &quot;LINESTRING(10 5, 9 4, 8 3, 7 2, 6 1)&quot; st_as_binary(x) #&gt; [1] 01 02 00 00 00 05 00 00 00 00 00 00 00 00 00 24 40 00 00 00 00 00 00 #&gt; [24] 14 40 00 00 00 00 00 00 22 40 00 00 00 00 00 00 10 40 00 00 00 00 00 #&gt; [47] 00 20 40 00 00 00 00 00 00 08 40 00 00 00 00 00 00 1c 40 00 00 00 00 #&gt; [70] 00 00 00 40 00 00 00 00 00 00 18 40 00 00 00 00 00 00 f0 3f How to control geometries for simplicity and validity? st_is_valid(st_as_sfc(&quot;POLYGON((0 0, 0 10, 10 0, 10 10, 0 0))&quot;)) #&gt; Warning in eval(substitute(expr), envir, enclos): Self-intersection at or #&gt; near point 5 5 #&gt; [1] FALSE st_is_simple(st_as_sfc(&quot;POLYGON((0 0, 0 10, 10 0, 10 10, 0 0))&quot;)) #&gt; [1] TRUE plot(st_as_sfc(&quot;POLYGON((0 0, 0 10, 10 0, 10 10, 0 0))&quot;)) How to create a grid manually? library(dplyr) lat &lt;- seq(from = 1, to = 50, length.out = 100) long &lt;- seq(from = 1, to = 50, length.out = 100) grid &lt;- tidyr::expand(tibble(lat = lat, long = long), lat, long) grid &lt;- grid %&gt;% mutate(points = purrr::map2(lat, long, ~st_geometrycollection(list(st_point(c(.x,.y)))))) grid &lt;- grid %&gt;% mutate(points = st_sfc(points)) grid &lt;- st_sf(grid, stringsAsFactors = FALSE, sf_column_name = &quot;points&quot;) plot(grid %&gt;% select(points)) How to set aggregations? # while initializing nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;), agr = c(AREA = &quot;aggregate&quot;, PERIMETER = &quot;aggregate&quot;, CNTY_ = &quot;identity&quot;, CNTY_ID = &quot;identity&quot;, NAME = &quot;identity&quot;, FIPS = &quot;identity&quot;, FIPSNO = &quot;identity&quot;, CRESS_ID = &quot;identity&quot;, BIR74 = &quot;aggregate&quot;, SID74 = &quot;aggregate&quot;, NWBIR74 = &quot;aggregate&quot;, BIR79 = &quot;aggregate&quot;, SID79 = &quot;aggregate&quot;, NWBIR79 = &quot;aggregate&quot;)) #&gt; Reading layer `nc&#39; from data source `D:\\R\\Projects\\Tidyverse-Cookbook\\packrat\\lib\\x86_64-w64-mingw32\\3.3.3\\sf\\shape\\nc.shp&#39; using driver `ESRI Shapefile&#39; #&gt; converted into: POLYGON #&gt; Simple feature collection with 100 features and 14 fields #&gt; Attribute-geometry relationship: 0 constant, 8 aggregate, 6 identity #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #&gt; epsg (SRID): 4267 #&gt; proj4string: +proj=longlat +datum=NAD27 +no_defs 20.3 Arithmetics How to calculate with simple features? st_polygon(list(rbind(c(0,0),c(1,0),c(1,1),c(0,1),c(0,0)))) - 0.5 #&gt; POLYGON((-0.5 -0.5, 0.5 -0.5, 0.5 0.5, -0.5 0.5, -0.5 -0.5)) st_point(c(0,0)) + 1 #&gt; POINT(1 1) How to calculate distances? x = st_transform(nc, 32119) st_distance(x[c(1,4,22),], x[c(1, 33,55,56),], dist_fun = geosphere::distGeo) #&gt; Units: m #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0.00 312184.9 128341.85 475623.3 #&gt; [2,] 440561.15 114939.7 590434.80 0.0 #&gt; [3,] 18944.03 352719.1 78756.89 517527.8 line = st_sfc(st_linestring(rbind(c(30,30), c(40,40))), crs = 4326) st_length(line) #&gt; 1434649 m 20.4 Plots How does the plot method and its add argument work? plot(nc[1,1], col = &#39;grey&#39;) plot(nc[1,1], col = &#39;grey&#39;) plot(nc[1], add = TRUE) plot(nc[1]) plot(nc[1,1], col = &#39;grey&#39;, add = TRUE) Some differenct plot options plot(nc[1]) plot(st_convex_hull(nc[1])) plot(nc[1], border = grey(.5)) 20.5 Resources sf-page tidy spatial data in R with … (blogpost) sf-issue: dplyr compatibility "]
]
